---
description: Performance Guidelines - Diretrizes para otimiza√ß√£o de desempenho e m√©tricas Core Web Vitals
globs: src/**/*.{ts,tsx}
alwaysApply: true
---

# Performance Guidelines - Diretrizes de Desempenho

## **Vis√£o Geral**

Diretrizes completas para otimiza√ß√£o de desempenho web, incluindo Core Web Vitals, otimiza√ß√£o de imagens, code splitting, cache eficiente, e preven√ß√£o de problemas de performance comuns.

---

## üìä Core Web Vitals

### **M√©tricas Essenciais**

As m√©tricas Core Web Vitals s√£o indicadores cr√≠ticos de experi√™ncia do usu√°rio e s√£o utilizadas pelo Google para ranking:

#### **1. Largest Contentful Paint (LCP)**

Tempo at√© o maior elemento vis√≠vel ser renderizado. Meta: **< 2.5 segundos**.

#### **‚úÖ DO: Otimizar LCP**

```typescript
// ‚úÖ DO: Lazy loading de imagens grandes
<img
  src="/hero-image.webp"
  alt="Hero image"
  title="Hero image"
  loading="lazy"
  decoding="async"
  fetchpriority="high" // Apenas para imagem hero acima da dobra
/>

// ‚úÖ DO: Preload de recursos cr√≠ticos
<link rel="preload" href="/fonts/main-font.woff2" as="font" type="font/woff2" crossOrigin="anonymous" />
<link rel="preload" href="/critical.css" as="style" />

// ‚úÖ DO: Otimizar fontes
<link
  rel="preconnect"
  href="https://fonts.googleapis.com"
  crossOrigin="anonymous"
/>
<link
  rel="dns-prefetch"
  href="https://fonts.googleapis.com"
/>
```

#### **‚ùå DON'T: Bloquear Renderiza√ß√£o com Recursos N√£o Cr√≠ticos**

```typescript
// ‚ùå DON'T: Importar CSS pesado no in√≠cio
import "./heavy-styles.css"; // Bloqueia renderiza√ß√£o

// ‚ùå DON'T: Carregar imagens grandes sem otimiza√ß√£o
<img src="/huge-image.jpg" alt="Image" /> // Sem lazy loading

// ‚ùå DON'T: Usar fontes sem preload
@import url('https://fonts.googleapis.com/css2?family=...'); // Bloqueia renderiza√ß√£o
```

#### **2. First Contentful Paint (FCP)**

Tempo at√© o primeiro pixel de conte√∫do ser renderizado. Meta: **< 1.8 segundos**.

#### **‚úÖ DO: Otimizar FCP**

```typescript
// ‚úÖ DO: CSS cr√≠tico inline ou preload
<style dangerouslySetInnerHTML={{ __html: criticalCSS }} />

// ‚úÖ DO: Remover render-blocking JavaScript
// Usar async ou defer para scripts n√£o cr√≠ticos
<script src="analytics.js" async />

// ‚úÖ DO: Minimizar JavaScript inicial
// Code splitting para reduzir bundle inicial
const HeavyComponent = lazy(() => import('./HeavyComponent'));
```

#### **3. Cumulative Layout Shift (CLS)**

Estabilidade visual - mudan√ßas inesperadas de layout. Meta: **< 0.1**.

#### **‚úÖ DO: Prevenir Layout Shift**

```typescript
// ‚úÖ DO: Definir dimens√µes de imagens
<img
  src="/image.webp"
  alt="Image"
  title="Image"
  width={800}
  height={600}
  loading="lazy"
/>

// ‚úÖ DO: Reservar espa√ßo para elementos din√¢micos
<div className="h-64 w-full bg-gray-100 animate-pulse">
  {/* Skeleton loader mant√©m espa√ßo */}
</div>

// ‚úÖ DO: Usar aspect-ratio para containers
<div className="aspect-video w-full">
  <img src="/video-thumbnail.webp" alt="Thumbnail" />
</div>

// ‚úÖ DO: Evitar inserir conte√∫do acima do conte√∫do existente
// Usar transform ou position: absolute quando necess√°rio
```

#### **‚ùå DON'T: Causar Layout Shift**

```typescript
// ‚ùå DON'T: Imagens sem dimens√µes
<img src="/image.jpg" alt="Image" /> // Causa CLS

// ‚ùå DON'T: Fontes sem fallback adequado
// FOUC (Flash of Unstyled Content) causa CLS

// ‚ùå DON'T: Adicionar conte√∫do din√¢mico sem reservar espa√ßo
{data && <div>{data}</div>} // Pode causar shift se data chegar depois
```

#### **4. Interaction to Next Paint (INP)**

Tempo de resposta a intera√ß√µes do usu√°rio. Meta: **< 200 milissegundos**.

#### **‚úÖ DO: Otimizar Interatividade**

```typescript
// ‚úÖ DO: Debounce em inputs pesados
import { useDebouncedCallback } from 'use-debounce';

function SearchInput() {
  const [search, setSearch] = useState('');
  
  const debouncedSearch = useDebouncedCallback(
    (value: string) => {
      // Executar busca apenas ap√≥s 300ms de inatividade
      performSearch(value);
    },
    300
  );
  
  return (
    <input
      value={search}
      onChange={(e) => {
        setSearch(e.target.value);
        debouncedSearch(e.target.value);
      }}
    />
  );
}

// ‚úÖ DO: Usar requestIdleCallback para tarefas n√£o cr√≠ticas
if ('requestIdleCallback' in window) {
  requestIdleCallback(() => {
    // Processar dados n√£o cr√≠ticos
    processAnalytics();
  });
}

// ‚úÖ DO: Web Workers para processamento pesado
const worker = new Worker('/analytics-worker.js');
worker.postMessage({ data: heavyData });
```

#### **5. Total Blocking Time (TBT)**

Tempo total que o thread principal est√° bloqueado. Meta: **< 200 milissegundos**.

#### **‚úÖ DO: Reduzir TBT**

```typescript
// ‚úÖ DO: Code splitting e lazy loading
const Dashboard = lazy(() => import('./Dashboard'));
const Settings = lazy(() => import('./Settings'));

// ‚úÖ DO: Usar React.memo para componentes pesados
export const ExpensiveComponent = React.memo(({ data }) => {
  // Componente que renderiza muitos itens
  return <div>{/* ... */}</div>;
});

// ‚úÖ DO: Virtualiza√ß√£o para listas grandes
import { useVirtualizer } from '@tanstack/react-virtual';

function VirtualizedList({ items }) {
  const parentRef = useRef();
  const virtualizer = useVirtualizer({
    count: items.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => 50,
  });
  
  return (
    <div ref={parentRef} className="h-96 overflow-auto">
      <div style={{ height: `${virtualizer.getTotalSize()}px` }}>
        {virtualizer.getVirtualItems().map((virtualItem) => (
          <div key={virtualItem.key}>{items[virtualItem.index]}</div>
        ))}
      </div>
    </div>
  );
}
```

#### **6. Speed Index**

Tempo at√© o conte√∫do vis√≠vel ser preenchido. Meta: **< 3.4 segundos**.

#### **‚úÖ DO: Otimizar Speed Index**

```typescript
// ‚úÖ DO: Priorizar conte√∫do acima da dobra
// Renderizar conte√∫do cr√≠tico primeiro

// ‚úÖ DO: Skeleton loaders para conte√∫do ass√≠ncrono
function DataCardSkeleton() {
  return (
    <div className="animate-pulse">
      <div className="h-4 bg-gray-200 rounded w-3/4 mb-2"></div>
      <div className="h-8 bg-gray-200 rounded w-1/2"></div>
    </div>
  );
}

// ‚úÖ DO: Progressive loading
// Carregar imagens em qualidade baixa primeiro, depois alta
```

---

## üñºÔ∏è Otimiza√ß√£o de Imagens

### **‚úÖ DO: Boas Pr√°ticas de Imagens**

```typescript
// ‚úÖ DO: Formatos modernos (WebP, AVIF)
<picture>
  <source srcSet="/image.avif" type="image/avif" />
  <source srcSet="/image.webp" type="image/webp" />
  <img src="/image.jpg" alt="Image" title="Image" loading="lazy" />
</picture>

// ‚úÖ DO: Responsive images com srcSet
<img
  srcSet="/image-320w.webp 320w,
          /image-640w.webp 640w,
          /image-1280w.webp 1280w"
  sizes="(max-width: 640px) 320px,
         (max-width: 1280px) 640px,
         1280px"
  src="/image-1280w.webp"
  alt="Image"
  title="Image"
  loading="lazy"
/>

// ‚úÖ DO: Lazy loading (exceto para imagens acima da dobra)
<img
  src="/below-fold-image.webp"
  alt="Image"
  title="Image"
  loading="lazy"
  decoding="async"
/>

// ‚úÖ DO: fetchpriority para imagens cr√≠ticas
<img
  src="/hero-image.webp"
  alt="Hero"
  title="Hero"
  fetchpriority="high"
  loading="eager"
/>

// ‚úÖ DO: Dimens√µes expl√≠citas para prevenir CLS
<img
  src="/image.webp"
  alt="Image"
  title="Image"
  width={800}
  height={600}
  loading="lazy"
/>
```

#### **‚ùå DON'T: Imagens N√£o Otimizadas**

```typescript
// ‚ùå DON'T: Imagens sem otimiza√ß√£o
<img src="/huge-image.jpg" alt="Image" /> // Sem lazy, sem formato moderno

// ‚ùå DON'T: Lazy loading em imagens acima da dobra
<img src="/hero.jpg" loading="lazy" /> // Deve ser "eager"

// ‚ùå DON'T: Imagens sem dimens√µes
<img src="/image.jpg" /> // Causa CLS
```

---

## üì¶ Code Splitting e Lazy Loading

### **‚úÖ DO: Code Splitting Inteligente**

```typescript
// ‚úÖ DO: Lazy loading de rotas
import { lazy, Suspense } from 'react';

const Dashboard = lazy(() => import('./Dashboard'));
const Settings = lazy(() => import('./Settings'));

function App() {
  return (
    <Suspense fallback={<PageSkeleton />}>
      <Routes>
        <Route path="/dashboard" element={<Dashboard />} />
        <Route path="/settings" element={<Settings />} />
      </Routes>
    </Suspense>
  );
}

// ‚úÖ DO: Lazy loading de componentes pesados
const ChartComponent = lazy(() => import('./ChartComponent'));
const DataTable = lazy(() => import('./DataTable'));

// ‚úÖ DO: Dynamic imports condicionais
const loadFeature = async () => {
  if (shouldLoadFeature()) {
    const { FeatureComponent } = await import('./FeatureComponent');
    return FeatureComponent;
  }
  return null;
};

// ‚úÖ DO: Preload de rotas prov√°veis
const preloadRoute = (routeLoader: () => Promise<unknown>) => {
  const link = document.createElement('link');
  link.rel = 'prefetch';
  link.as = 'script';
  link.href = routeLoader.toString();
  document.head.appendChild(link);
};

// Preload ao hover
<Link
  to="/dashboard"
  onMouseEnter={() => preloadRoute(() => import('./Dashboard'))}
>
  Dashboard
</Link>
```

#### **‚ùå DON'T: Importa√ß√µes S√≠ncronas de Componentes Grandes**

```typescript
// ‚ùå DON'T: Importar tudo de uma vez
import { HeavyComponent1, HeavyComponent2, HeavyComponent3 } from './components';

// ‚ùå DON'T: Lazy loading desnecess√°rio para componentes pequenos
// Componentes < 10KB n√£o precisam de lazy loading
const SmallButton = lazy(() => import('./SmallButton')); // N√£o √© necess√°rio
```

---

## üíæ Cache Eficiente

### **‚úÖ DO: Estrat√©gias de Cache**

```typescript
// ‚úÖ DO: React Query com staleTime apropriado
export function useDashboardData() {
  return useQuery({
    queryKey: ['dashboard'],
    queryFn: fetchDashboardData,
    staleTime: 5 * 60 * 1000, // 5 minutos - dados frescos
    gcTime: 10 * 60 * 1000, // 10 minutos - cache mantido
    refetchOnWindowFocus: false, // Evitar refetch desnecess√°rio
  });
}

// ‚úÖ DO: Service Workers para cache offline
// Implementar estrat√©gia cache-first para assets est√°ticos

// ‚úÖ DO: HTTP Cache Headers (backend)
// Cache-Control: public, max-age=31536000, immutable (para assets est√°ticos)
// Cache-Control: public, max-age=300, must-revalidate (para dados din√¢micos)

// ‚úÖ DO: Memoiza√ß√£o de c√°lculos pesados
import { useMemo } from 'react';

function ExpensiveComponent({ data }) {
  const processedData = useMemo(() => {
    // C√°lculo pesado
    return heavyProcessing(data);
  }, [data]);
  
  return <div>{processedData}</div>;
}

// ‚úÖ DO: React.memo para componentes que recebem props est√°veis
export const MemoizedCard = React.memo(({ title, value }) => {
  return (
    <Card>
      <CardTitle>{title}</CardTitle>
      <CardValue>{value}</CardValue>
    </Card>
  );
});
```

#### **‚ùå DON'T: Cache Ineficiente**

```typescript
// ‚ùå DON'T: Refetch desnecess√°rio
useQuery({
  queryKey: ['data'],
  queryFn: fetchData,
  refetchOnWindowFocus: true, // Pode ser desnecess√°rio
  refetchInterval: 1000, // Muito frequente
});

// ‚ùå DON'T: Sem cache para dados est√°ticos
// Dados que raramente mudam devem ter staleTime alto

// ‚ùå DON'T: Recalcular em cada render
function Component({ data }) {
  const processed = heavyProcessing(data); // Recalcula sempre
  return <div>{processed}</div>;
}
```

---

## üö´ Preven√ß√£o de Reflow For√ßado

### **‚úÖ DO: Evitar Reflows Desnecess√°rios**

```typescript
// ‚úÖ DO: Ler propriedades antes de escrever
function optimizeLayout() {
  // Ler todas as propriedades primeiro
  const width = element.offsetWidth;
  const height = element.offsetHeight;
  const scrollTop = element.scrollTop;
  
  // Depois fazer todas as modifica√ß√µes
  element.style.width = `${width + 10}px`;
  element.style.height = `${height + 10}px`;
  element.scrollTop = scrollTop + 10;
}

// ‚úÖ DO: Usar transform em vez de position/width/height
// Transform n√£o causa reflow
<div className="transform translate-x-4 scale-105" />

// ‚úÖ DO: Usar will-change para anima√ß√µes
<div className="will-change-transform" style={{ transform: `translateX(${x}px)` }} />

// ‚úÖ DO: Batch DOM updates
// React j√° faz isso automaticamente, mas cuidado com manipula√ß√£o direta
requestAnimationFrame(() => {
  // Todas as mudan√ßas de DOM aqui
  element1.style.width = '100px';
  element2.style.height = '200px';
});
```

#### **‚ùå DON'T: Causar Reflows Desnecess√°rios**

```typescript
// ‚ùå DON'T: Alternar entre ler e escrever
function badLayout() {
  element.style.width = '100px';
  const width = element.offsetWidth; // Reflow for√ßado
  element.style.height = `${width}px`;
  const height = element.offsetHeight; // Reflow for√ßado
}

// ‚ùå DON'T: Modificar layout em loops
for (let i = 0; i < 1000; i++) {
  element.style.left = `${i}px`; // Reflow a cada itera√ß√£o
}

// ‚ùå DON'T: Acessar propriedades de layout ap√≥s modifica√ß√µes
element.style.display = 'none';
const width = element.offsetWidth; // Reflow
```

---

## üåê Otimiza√ß√£o de Rede

### **‚úÖ DO: Otimizar Requisi√ß√µes**

```typescript
// ‚úÖ DO: Debounce em buscas
import { useDebouncedCallback } from 'use-debounce';

function SearchInput() {
  const debouncedSearch = useDebouncedCallback(
    (value: string) => fetchResults(value),
    300
  );
  
  return <input onChange={(e) => debouncedSearch(e.target.value)} />;
}

// ‚úÖ DO: Request deduplication (React Query faz isso automaticamente)
// M√∫ltiplas chamadas com mesma queryKey s√£o deduplicadas

// ‚úÖ DO: Pagina√ß√£o e infinite scroll
function useInfiniteData() {
  return useInfiniteQuery({
    queryKey: ['items'],
    queryFn: ({ pageParam = 0 }) => fetchItems(pageParam),
    getNextPageParam: (lastPage) => lastPage.nextPage,
  });
}

// ‚úÖ DO: Prefetch de dados prov√°veis
const queryClient = useQueryClient();

function onHover() {
  queryClient.prefetchQuery({
    queryKey: ['dashboard'],
    queryFn: fetchDashboardData,
  });
}

// ‚úÖ DO: Otimistic updates
const mutation = useMutation({
  mutationFn: updateItem,
  onMutate: async (newItem) => {
    // Cancelar queries em andamento
    await queryClient.cancelQueries({ queryKey: ['items'] });
    
    // Snapshot do estado anterior
    const previousItems = queryClient.getQueryData(['items']);
    
    // Atualiza√ß√£o otimista
    queryClient.setQueryData(['items'], (old: Item[]) => [
      ...old,
      newItem,
    ]);
    
    return { previousItems };
  },
  onError: (err, newItem, context) => {
    // Rollback em caso de erro
    queryClient.setQueryData(['items'], context.previousItems);
  },
});
```

#### **‚ùå DON'T: Requisi√ß√µes Ineficientes**

```typescript
// ‚ùå DON'T: Fetch sem debounce em inputs
<input onChange={(e) => fetchData(e.target.value)} /> // Muitas requisi√ß√µes

// ‚ùå DON'T: Buscar todos os dados de uma vez
fetchAllData(); // Pode ser muito pesado

// ‚ùå DON'T: Sem cache
fetchData(); // Sempre busca do servidor
```

---

## üìä Bundle Size e Tree Shaking

### **‚úÖ DO: Minimizar Bundle Size**

```typescript
// ‚úÖ DO: Importa√ß√µes espec√≠ficas
import { Button } from '@/components/ui/button'; // ‚úÖ
// N√£o: import * from '@/components/ui';

// ‚úÖ DO: Usar tree-shaking friendly libraries
import { format } from 'date-fns'; // ‚úÖ
// N√£o: import dateFns from 'date-fns';

// ‚úÖ DO: Analisar bundle size
// npm run build -- --analyze
// ou usar vite-bundle-visualizer

// ‚úÖ DO: Remover depend√™ncias n√£o utilizadas
// npm audit e npm prune regularmente

// ‚úÖ DO: Usar dynamic imports para bibliotecas grandes
const loadChartLibrary = async () => {
  const { Chart } = await import('chart.js');
  return Chart;
};
```

#### **‚ùå DON'T: Bundle Size Desnecess√°rio**

```typescript
// ‚ùå DON'T: Importar bibliotecas completas
import _ from 'lodash'; // Muito pesado
import * as dateFns from 'date-fns'; // Importa tudo

// ‚ùå DON'T: Depend√™ncias duplicadas
// Verificar package.json para duplica√ß√µes

// ‚ùå DON'T: Assets n√£o otimizados
// Imagens grandes, fontes n√£o subsetadas
```

---

## üîß Ferramentas de Monitoramento

### **‚úÖ DO: Implementar Web Vitals**

```typescript
// ‚úÖ DO: Configurar Web Vitals
import { reportWebVitals } from '@/core/utils/web-vitals';
import { ENV_CONFIG } from '@/core/config/env.config';

// No main.tsx ou App.tsx
if (ENV_CONFIG.VITE_ENABLE_WEB_VITALS === 'true') {
  reportWebVitals((metric) => {
    // Enviar para Sentry ou analytics
    console.log('[WebVitals]', metric.name, metric.value);
    
    // Enviar para Sentry
    if (metric.value > threshold) {
      Sentry.captureMessage(`Poor ${metric.name}: ${metric.value}`, 'warning');
    }
  });
}

// ‚úÖ DO: Monitorar performance com Sentry
import * as Sentry from '@sentry/react';

Sentry.init({
  tracesSampleRate: 1.0, // Em desenvolvimento
  // tracesSampleRate: 0.1, // Em produ√ß√£o
});

// ‚úÖ DO: Performance marks e measures
performance.mark('component-start');
// ... c√≥digo do componente ...
performance.mark('component-end');
performance.measure('component-render', 'component-start', 'component-end');
```

### **‚úÖ DO: Lighthouse CI**

```bash
# ‚úÖ DO: Executar Lighthouse em CI/CD
npm install -g @lhci/cli
lhci autorun --config=lighthouserc.json
```

### **‚úÖ DO: Bundle Analyzer**

```bash
# ‚úÖ DO: Analisar bundle size
npm install --save-dev vite-bundle-visualizer
# Adicionar ao vite.config.ts
```

---

## üéØ Checklist de Performance

### **Core Web Vitals**

- [ ] LCP < 2.5 segundos
- [ ] FCP < 1.8 segundos
- [ ] CLS < 0.1
- [ ] INP < 200 milissegundos
- [ ] TBT < 200 milissegundos
- [ ] Speed Index < 3.4 segundos

### **Otimiza√ß√µes de Imagens**

- [ ] Todas as imagens t√™m `alt` e `title`
- [ ] Imagens usam formatos modernos (WebP, AVIF)
- [ ] Lazy loading em imagens abaixo da dobra
- [ ] Dimens√µes expl√≠citas para prevenir CLS
- [ ] Responsive images com `srcSet` quando necess√°rio
- [ ] `fetchpriority="high"` apenas para imagens hero cr√≠ticas

### **Code Splitting**

- [ ] Rotas com lazy loading
- [ ] Componentes pesados com lazy loading
- [ ] Suspense boundaries apropriados
- [ ] Preload de rotas prov√°veis

### **Cache**

- [ ] React Query configurado com `staleTime` apropriado
- [ ] Memoiza√ß√£o de c√°lculos pesados
- [ ] React.memo para componentes que recebem props est√°veis
- [ ] HTTP Cache Headers configurados no backend

### **Rede**

- [ ] Debounce em buscas e inputs
- [ ] Pagina√ß√£o ou infinite scroll para listas grandes
- [ ] Prefetch de dados prov√°veis
- [ ] Otimistic updates quando apropriado

### **Bundle**

- [ ] Bundle size analisado e otimizado
- [ ] Tree shaking funcionando corretamente
- [ ] Depend√™ncias n√£o utilizadas removidas
- [ ] Imports espec√≠ficos (n√£o `import *`)

### **Monitoramento**

- [ ] Web Vitals configurado e enviando m√©tricas
- [ ] Sentry rastreando performance
- [ ] Lighthouse CI configurado
- [ ] Bundle analyzer configurado

---

## üìö Refer√™ncias

- [Web Vitals](https://web.dev/vitals/)
- [Core Web Vitals](https://web.dev/vitals/)
- [Lighthouse](https://developers.google.com/web/tools/lighthouse)
- [React Performance Optimization](https://react.dev/learn/render-and-commit)
- [Vite Performance Guide](https://vitejs.dev/guide/performance.html)
- [Web.dev Performance](https://web.dev/performance/)

---

**√öltima atualiza√ß√£o**: 2024  
**Vers√£o**: 1.0.0
